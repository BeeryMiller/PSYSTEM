*BIOS2 1/5/89.1
*RECONSTRUCTED FROM LIST FILE 12/29/88.1

*CHARACTER ORIENTED I/O

VIDLIB  DATA    6       XOP FOR VIDEO ACCESS
KSCAN   DATA    5       KEYSCAN XOP

******************************************

*SPECIAL CHARACTERS HANDLING

*CHARACTER HANDLING STATUS RECORD
*INDEXES INTO STRUCTURE

DEVOUT  EQU     0    BIOS OUTPUT ADDR FOR DEVICE IN QUESTION
DEVIN   EQU     2    BIOS INPUT ADDRESS
NSPC    EQU     4    IGNORE SPECIAL CHAR IF NONZERO
NCRLF   EQU     6    IGNORE AUTO LINEFEED IF NONZERO
DLESET  EQU     8    NEXT CHAR IS SPACE COUNT IF TRUE
NEWLIN  EQU     10   NEXT CHAR STARTS A NEW LINE IF TRUE
ALPLOK  EQU     12   UPPER CASE ONLY IF SET

*************************************************
* SETS THE LOCAL CRLF AND NOSPEC FLAGS
* BASED ON THE VALUES PASSED BY UNITIO CONTROL WORD
* ENTRY:
*       R5=^DEVICE RECORD
* EXIT:
*       FLAGS SET

SETREC  MOV     @NOSPEC,@NSPC(R5)  SPECIAL CHARACTER FLAG
        MOV     @NOCRLF,@NCRLF(R5)
        RT

*******************REMOTE UNIT SERVICE

REMCTR  CLR     @IORSLT  STUB
        B       *BK

*REMOTE UNIT STATUS RECORD
REMREC  DATA    RMOBIO,RMIBIO
        BSS     10
*
RMIPAB  BSS     15      SERVICE PAB MAINTAINED FOR REM UNIT
        BYTE    16      LENGTH OF FILE NAME
        TEXT    'RS232/2.BA=9600.'
        EVEN

RMOPAB  BSS     15      SERVICE PAB MAINTAINED FOR REM UNIT
        BYTE    14      LENGTH OF FILE NAME
       TEXT 'RS232/2.BA=9600.'

*
REMCLR  LI      R0,>0014 '00010100' SEQUENTIAL, INPUT, DISPLAY
*                        VARIABLE RECORDS
        MOV     R0,@RMIPAB  SET MODE BYTE & OPCODE
        LI      R0,SGCHR BUFFER FOR CHARACTER
        MOV     R0,@RMIPAB+4
        LI      R0,RMIPAB
        XOP     @IOLIB,0  OPEN THE CHANNEL
        LI      R0,>0012 '00010010' SEQUENTIAL, OUTPUT, DISP
*                        VARIABLE RECORDS
        MOV     R0,@RMOPAB  SET MODE BYTE & OPCODE
        LI      R0,SGCHR BUFFER FOR CHARACTER
        MOV     R0,@RMOPAB+4
        LI      R0,RMOPAB
        XOP     @IOLIB,0  OPEN THE CHANNEL
        LI      R0,RMOPAB
        BL      @GETERR
        LI      R0,REMREC
        B       @CLR

*REMOTE STATUS ROUTINE
*RETURNS MYARC STATUS BYTE @STATUS RECORD+29
*SETS IORSLT
*NO OTHER INFO IS RETURNED AT THIS TIME HOWEVER ANY OF THE
*BYTES 0-28 ARE AVAILABLE FOR FUTURE EXTENSIONS
*EXPECTS STATUS RECORD POINTER AT USTAT

REMST   LI      R0,>0900 STATUS OPCODE
        MOVB    R0,@RMIPAB
        LI      R0,RMIPAB
        XOP     @IOLIB,0
        BL      @GETERR  ASSUMES R0 STILL INTACT AFTER XOP
        MOV     @USTAT,R0
        AI      R0,29
        MOVB    @RMIPAB+14,*R0   WRITE TO LAST BYTE OF RECORD
*
       CLR  @IORSLT
        B       *BK

*BIOS LEVEL REMOUT
*       ENTRY: CHR IS IN HIBYTE OF SGCHR
*       EXIT: CHR WRITTEN, IORSLT SET, R0 ALTERED

*BIOS LEVEL PRTOUT
*       ENTRY: CHR IS IN HIBYTE OF SGCHR
*       EXIT: CHR WRITTEN, IORSLT SET, R0 ALTERED

RMOBIO MOV  R11,@RMOB99+2
       LI   R0,>0302          WRITE OPCODE - DF, OUTPUT, SEQUENTIAL
       MOV  R0,@RMOPAB        SET MODE BYTE & OPCODE
*
       CLR  @RMOPAB+2
*
       LI   R0,PRTCHR
       MOV  @SGCHR,*R0
       MOV  R0,@RMOPAB+4
*
       CLR  @RMOPAB+6
       CLR  @RMOPAB+8
       CLR  @RMOPAB+10
       MOVB @H00,@RMOPAB+14
*
       LI   R0,1    1 CHARACTER
       MOV  R0,@RMOPAB+12
       LI   R0,RMOPAB

       XOP  @IOLIB,0
       BL   @GETERR
RMOB99 B    @0


*BIOS LEVEL REMIN
*       ENTRY:  NONE
*       EXIT:   CHR IN SGCHR, IORSLT SET, R0 ALTERED

RMIBIO  MOV     R11,@RMOBIO-2
        LI      R0,>0200 READ OPCODE
        MOVB    R0,@RMIPAB
        LI      R0,1    1 CHARACTER
        MOV     R0,@RMIPAB+12
        LI      R0,RMIPAB
        XOP     @IOLIB,0
        BL      @GETERR
        MOV     @RMOBIO-2,R11
        RT


*REMOTE  READ ROUTINE (RSP LEVEL)
*MODIFIED FOR LONG ADDRESS 1/30/88

*BUFFER CAN CONTAIN ANY NUMBER OF CHARACTERS
*SOURCE BUFFER IS ALWAYS IN STACK HEAP RAM

*ENTRY: DSKADR=HIWORD (ALWAYS 0)
*       DSKADR+2=16 BIT ADDRESS OF DESTINATION
*       BYTCNT=# BYTES TO WRITE (VALUE DESTROYED AFTER CALL)
*DOES NOT DO ANY SPECIAL CHARACTER FILTERING
*       EXCEPT ALPHALOCK

REMIN   LI      R5,REMREC
        BL      @SETREC SET THE LOCAL RECORD
        MOV     @DSKADR+2,R7  R7=^DEST BUFFER
       MOV  @BYTCNT,@BYTCNT
       JEQ  RMIN3
*
RMIN1   BL      @RMIBIO  READ THE CHAR
        MOV     @REMREC+ALPLOK,@REMREC+ALPLOK
        JEQ     RMIN2   NOT ALPHALOCK
        BL      @CAPSET
RMIN2   MOVB    @SGCHR,*R7+   STORE THE BYTE
        DEC     @BYTCNT BYTCNT HAS BEEN SET BY UNITREAD
        JNE     RMIN1
RMIN3   B       *BK


*REMOTE WRITE ROUTINE (RSP LEVEL)
*BUFFER CAN CONTAIN ANY NUMBER OF CHARACTERS
*USING MULTIPLE CALLS TO PUTCHR
*ENTRY: DSKADR=HIWORD (ALWAYS 0)
*       DSKADR+2=16 BIT ADDRESS OF SOURCE
*       BYTCNT=# BYTES TO WRITE (VALUE DESTROYED AFTER CALL)

REMOUT  LI      R5,REMREC
       MOV  @DSKADR+2,R7      R7=^SOURCE BUFFER
        BL      @SETREC       SET LOCAL RECORD
        MOV @BYTCNT,@BYTCNT
       JEQ  REMO99
RMLOOP  MOVB    *R7+,@SGCHR   FETCH THE BYTE
        BL      @PUTCHR PRINT THE CHARACTER
        DEC     @BYTCNT BYTCNT HAS BEEN SET BY UNITWRITE
        JNE     RMLOOP
REMO99  B       *BK

*****PRINTER ROUTINES

*PRINTER STATUS RECORD
PRTREC DATA PROBIO,0
       BSS  10
*
PRTCHR DATA 0
PRTPAB  BSS     15
        BYTE    3        LENGTH OF NAME
        TEXT    'PIO'

PRTCLR  LI      R0,PRTREC
       CLR  R1
        B       @CLR

*STUB FOR PRINTER

PRTCTR
PRTST   CLR     @IORSLT
        B       *BK


*******************************************
*PRINTER ROUTINE (RSP LEVEL)
*BUFFER CAN CONTAIN ANY NUMBER OF CHARACTERS
*USING MULTIPLE CALLS TO PUTCHR
*ENTRY: DSKADR & DSKADR+2 CONTAIN 2 WORDS OF
*       SOURCE BUFFER.  2ND WORD IS TRUE ADDRESS
*       IN SYSTEM RAM BLOCK
*       BYTCNT=# BYTES TO WRITE (VALUE DESTROYED AFTER CALL)

PRTOUT  LI      R5,PRTREC
        MOV     @DSKADR+2,R7   R7=^SOURCE BUFFER
        BL      @SETREC
       MOV  @BYTCNT,@BYTCNT
       JEQ  PRTO99
*
PRTLP   MOVB    *R7+,@SGCHR    FETCH THE BYTE
        BL      @PUTCHR PRINT THE CHARACTER
        DEC     @BYTCNT BYTCNT HAS BEEN SET BY UNITWRITE
        JNE     PRTLP
PRTO99  B       *BK


*BIOS LEVEL PRTOUT
*       ENTRY: CHR IS IN HIBYTE OF SGCHR
*       EXIT: CHR WRITTEN, IORSLT SET, R0 ALTERED

PROBIO MOV  R11,@PROB99+2
       LI   R0,>0302          WRITE OPCODE - DF, OUTPUT, SEQUENTIAL
       MOV  R0,@PRTPAB        SET MODE BYTE & OPCODE
*
       CLR  @PRTPAB+2
*
       LI   R0,PRTCHR
       MOV  @SGCHR,*R0
       MOV  R0,@PRTPAB+4
*
       CLR  @PRTPAB+6
       CLR  @PRTPAB+8
       CLR  @PRTPAB+10
       MOVB @H00,@PRTPAB+14
*
       LI   R0,1    1 CHARACTER
       MOV  R0,@PRTPAB+12
       LI   R0,PRTPAB

       XOP  @IOLIB,0
       BL   @GETERR
PROB99 B    @0

*********************CONSOLE UNIT SERVICE

*CONSOLE UNIT STATUS RECORD
CONREC  DATA    CRTBIO,KEYBIO
        BSS     10

CONST
CONCTR  CLR     @IORSLT  STUB
        B       *BK


*SETS UP VIDE0 MODE 1 AND CLEARS SCREEN
CONCLR  CLR     R0
        LI      R1,1     VID MODE 1
*       XOP     @VIDLIB,0
        LI      R1,>0F04      WHITE ON BLACK TEXT COLOR
        LI      R0,>29
        XOP     @VIDLIB,0
*       LI      R0,>2000
*       MOVB    R0,@SGCHR
*       BL      @CRTBIO  PRINT A BLANK
        LI      R0,>1A00  FORMFEED
        MOVB    R0,@SGCHR
*       BL      @CRTBIO  CLEAR THE SCREEN
        LI      R0,CONREC
        B       @CLR

*******************************************
*GENERAL PURPOSE CLEAR ROUTINE
*ENTRY: R0=^DEVICE RECORD
*RESETS ALL CONTROL PARAMETERS

        BSS     2
CLR     MOV     R1,@CLR-2
        MOV     R0,R1    PROTECT THIS REGISTER
        CLR     @NSPC(R1)
        CLR     @NCRLF(R1)
        CLR     @DLESET(R1)
        CLR     @NEWLIN(R1)
        CLR     @ALPLOK(R1)
        MOV     @CLR-2,R1
        B       *BK

*CONSOLE READ ROUTINE RSP LEVEL
*ENTRY: DSKADR & DSKADR+2 CONTAIN 2 WORDS OF
*       SOURCE BUFFER.  2ND WORD IS TRUE ADDRESS
*       IN SYSTEM RAM BLOCK
*       BYTCNT=# BYTES TO READ  (VALUE DESTROYED AFTER CALL)

ECHOFL DATA 0

SYSRD  CLR  @ECHOFL
       JMP  CONR00

CONRD  SETO @ECHOFL
*
CONR00 MOV  @BYTCNT,@BYTCNT
       JEQ  CONR99
*
        MOV     @DSKADR+2,R7  DESTINATION BUFFER
        LI      R5,CONREC
        BL      @SETREC
        CLR     R5
        MOVB    @CHRMSK,R5
        INV     R5   NEGATIVE IMAGE OF MASK
        CLR     R6
        MOVB    @BRKCHR,R6  BREAK CHARACTER BYTE
CONR1   BL      @KEYBIO  GET THE NEXT KEY
        SZC     R5,@SGCHR    CHARACTER MASK
        MOV     @CONREC+ALPLOK,@CONREC+ALPLOK  ALPHA LOCK MODE?
        JEQ     CONR2    NO
        BL      @CAPSET
CONR2   MOVB    @SGCHR,*R7+   STORE BYTE

       MOV  @ECHOFL,@ECHOFL
       JEQ  CONR3

* * * * * *
*THIS SECTION ECHOS CHARACTER TO SCREEN AS IMPLIED BY PG 6-28
*HOWEVER THIS IS NOT SPECIFIED IN THE DESCRIPTION OF THE RSP I/O
*CAN BE ELIMINATED WITHOUT PROBLEM
        BL      @CRTBIO  PRINT TO SCREEN
        CLR     R1
        MOVB    @SGCHR,R1
        CI      R1,>0D00 NEW LINE?
        JNE     CONR3
        LI      R1,>0A00 LINEFEED
        MOVB    R1,@SGCHR
        BL      @CRTBIO  ECHO TO SCREEN
**********

CONR3   DEC     @BYTCNT
        JNE     CONR1    GET ANOTHER CHARACTER
CONR99 CLR  @ECHOFL
        B       *BK

* WAITS FOR THE NEXT KEY AND RETURNS
* KEY VALUE IN SGCHR TO STAY COMPATATIBLE WITH OTHER
* CHARACTER BASED INPUT

       DATA >5678


KEYBIO MOV  R11,@KEYB99+2
*
*      get cursor position
*
       LI   R0,>0003
       XOP  @VIDLIB,0
*
*      get character from screen
*
       MOV  R1,R2
       MOV  R0,R1
*
       IF   DEBUG
       MOV  R1,R0
       SLA  R0,8
       BLWP @RSBYTE
       MOV  R2,R0
       SLA  R0,8
       BLWP @RSBYTE
       FI
*
       LI   R0,>000B
       XOP  @VIDLIB,0
       MOV  R0,@KEYB40
*
       IF   DEBUG
       SLA  R0,8
       BLWP @RSBYTE
       FI
*
* loop while waiting for a real keystroke
*
KEYB10 MOV  @KEYB40,R4
       MOVB @>F131,R0         get tenths second from clock
       CI   R0,>3500          > 5, display current character
       JHE  KEYB15
*
       LI   R4,'_'            < 5, display underline for cursor

KEYB15 BL   @KEYB60           write character to screen from R1
*
       LI   R0,4              pascal scan mode 2/8/91
       XOP  @KSCAN,0          get keyboard character
       JNE  KEYB10            no key pressed, redisplay cursor
       MOVB R1,@SGCHR         save key value
*
       MOV  @KEYB40,R4
       BL   @KEYB60           write character back to screen
KEYB99 B    @0
*
KEYB40 DATA 0                 character under cursor
*
* write character to screen
*
KEYB60 LI   R0,>002A
       STWP R1                address of string
       AI   R1,9              (in R4L)
       LI   R2,1              1 char
       SETO R3                don't update cursor
       XOP  @VIDLIB,0
KEYB69 RT

*******************************************
*CONSOLE WRITE ROUTINE (RSP LEVEL)
*   REV 12/28/88
*BUFFER CAN CONTAIN ANY NUMBER OF CHARACTERS
*USING MULTIPLE CALLS TO PUTCHR
*ENTRY: DSKADR & DSKADR+2 CONTAIN 2 WORDS OF
*       SOURCE BUFFER.  2ND WORD IS TRUE ADDRESS
*       IN SYSTEM RAM BLOCK
*       BYTCNT=# BYTES TO WRITE (VALUE DESTROYED AFTER CALL)


CONWRT MOV  @BYTCNT,@BYTCNT
       JEQ  CONW99
*
        LI      R5,CONREC      CONSOLE STATUS RECORD
        BL      @SETREC
        MOV     @DSKADR+2,R7   R7=^SOURCE BUFFER
CNLOOP  MOVB    *R7+,@SGCHR    FETCH THE BYTE
        BL      @PUTCHR PRINT THE CHARACTER
        DEC     @BYTCNT BYTCNT HAS BEEN SET BY UNITWRITE
        JNE     CNLOOP
CONW99  B       *BK

********************************************
*CONVERTS TO CAPITAL LETTERS
*ENTRY CHAR=@SGCHR
*EXIT CHAR CONVERTED IF REQUIRED

CAPSET  CLR     R1
        MOVB    @SGCHR,R1
        CI      R1,>6100
        JLT     CPST1        ASC<97
        CI      R1,>7A00     ASC>122
        JGT     CPST1
        ANDI    R1,>DF00
        MOVB    R1,@SGCHR
CPST1   RT
********************************************

*PUTCHR IS THE RSP LEVEL CHARACTER OUTPUT ROUTINE
*FOR PRINTER, TTY, REMOTE & SERIAL
*ACCESSED BY BL FROM THE APPORPRIATE DEVICE DRIVER
*    REV 12/28/88

*EACH OF THE CHARACTER DEVICES HAS ITS
*OWN SET OF FLAGS FOR SPECIAL CHARACTER STATUS
*THIS STATUS IS MAINTAINED BETWEEN CALLS
*IN THE DEVICE'S STATUS RECORD

*PUTCHR IS THE GENERAL PURPOSE ROUTINE FOR PLACING
*CHARACTERS IN THE APPROPRIATE OUTPUT DEVICE

*ENTRY: SGCHR=CHAR (IN MS BYTE)
*       R5=^RECORD FOR THIS DEVICE

*EXIT:  CHARACTER OUTPUTTED AS REQUIRED
*REGISTER USAGE: R3,R4,R5,R6 + REGISTERS ALTERED BY
*         BIOS ROUTINE CALLED

        BSS     2
PUTCHR  MOV     R11,@PUTCHR-2
        MOV     *R5,R4  GET BIOS ADDRESS
        CLR     R6
*
*      IF   DEBUG
*      JMP  PUTCH5
*      FI
*
        MOV     @NSPC(R5),@NSPC(R5) SPECIAL HANDLING
        JNE     PUTCH5  IGNORE SPECIAL CHARACTERS
        MOV     @DLESET(R5),@DLESET(R5)
        JEQ     PUTCH3  DLE FLAG IS NOT SET FOR THIS DEVICE

* DLE WAS SET; CLEAR IT AND EXPAND CHARACTER COUNT
        CLR     @DLESET(R5)   CLEAR DLE FLAG
        MOVB    @SGCHR,R6  CHECK THE COUNT
        JLT     PUTCH2  NEGATIVE BYTE VALUE, ABORT
        LI      R3,>2000  SPACE
        MOVB    R3,@SGCHR  EXPANDING OUT SPACES
        SWPB    R6      GET COUNT
        AI      R6,-32  NORMALIZE
        JLT     PUTCH2  NEGATIVE VAL AFTER NORM, ABORT
       JEQ  PUTCH2
PUTCH1  BL      *R4
        DEC     R6
        JNE     PUTCH1
        JMP     PUTCH2  DONE; RETURN

PUTCH3  MOVB    @SGCHR,R6
        CI      R6,>0D00  CR?
        JNE     PUTCH4   NOT A CR
        SETO    @NEWLIN(R5)   SET NEWLINE FLAG
        BL      *R4     CALL SPECIFIC BIOS ROUTINE
        MOV     @NCRLF(R5),@NCRLF(R5)   AUTO LINEFEED?
        JNE     PUTCH6   DONE
        LI      R2,>0A00  LINEFEED TO FOLLOW
        MOVB    R2,@SGCHR
        BL      *R4
        JMP     PUTCH6  DONE

PUTCH4  MOVB    @SGCHR,R6
        CI      R6,>1000  IS IT A DLE?
        JNE     PUTCH5  NOT A DLE EITHER
        MOV     @NEWLIN(R5),@NEWLIN(R5)  ONLY VALID AT START OF LINE
        JEQ     PUTCH6        CANT BE RIGHT
        SETO    @DLESET(R5)   SET DLE FLAG
        JMP     PUTCH2  DONE FOR THIS CHAR

*IF WE'VE GOTTEN THIS FAR, IT MUST BE AN ORDINARY CHARACTER
PUTCH5  BL      *R4     PRINT IT

PUTCH2  CLR     @NEWLIN(R5)
PUTCH6  MOV     @PUTCHR-2,R11 ENTER HERE ONLY AFTER SETTING NL
        RT

**************************************************
*BIOS LEVEL TTY OUTPUT ROUTINE
*ENTRY: CHAR IN SGCHR (HI BYTE)
*VERSION 9/4/87 SIMPLY PLACES CHARACTER ON SCREEN
*   ASSUMING THAT XOP HANDLES LF,CR,FF CORRECTLY
*   ALSO BELL IS CURRENTLY IGNORED

CRTBIO  CLR     R0
        MOVB    @SGCHR,R0     COPY OF BYTE
        JEQ     CRTBI1  NULL, GO BACK
        CI      R0,>0700 CHECK FOR BELL
        JNE     CRTBI2
*PUT BELL SERVICE ROUTINE HERE
        RT              RETURN
*
CRTBI2 CI   R0,>8800
       JL   CRTB50
       CI   R0,>8D00
       JH   CRTB50
       ANDI R0,>7F00
*
CRTB50  LI      R0,>27   OPCODE FOR TTY WRITE
        LI      R1,SGCHR
        LI      R2,1
        XOP     @VIDLIB,0
*
*      IF   DEBUG
*      MOVB @SGCHR,R0
*      BLWP @RSBYTE
*      FI
*
CRTBI1  RT
**************************************************


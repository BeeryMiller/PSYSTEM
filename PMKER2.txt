*PMKER2 1/8/89.1
*MODIFICATIONS FOR LINEAR ADDRESS
*ROUTINES CHANGED:
*       GETSEG
*       BLDFRM
*       CHGSIB

*GENERAL ROUTINES CONTINUED
*TRAVERSES LINKS
* ENTRY: R4=#LINKS TO TRAVERS
* EXIT: STATLK SET TO APPROPRIATE LINK
*       R2,R4 ALTERED


SETLNK  MOV     MP,R2   STATIC LINK TRAVERSAL
        MOV     R4,R4
        JEQ     STL2
STL1    MOV     *R2,R2  WALK UP STATIC CHAIN
        DEC     R4
        JGT     STL1    MORE TO GO
STL2    MOV     R2,@STATLK FOUND IT, SET LINK
        RT

*NOTE: CALLER RESPONSIBLE FOR CHECKING SEGMENT PRESENCE
*      BEFORE CALLING GETSEG, GETMAP

* * * * * * * * * * * * * * *
*GET SEG ADDRESS FOR SEGMENT
*RETURNS 24 BIT ADDRESS FROM EREC
*MODIFY FOR LINEAR ADDRESS USE 1/24/88
*ADD SEGMENT OFFSET FEATURE AND ROLLOVER HANDLING

*CALL FROM STACK/HEAP AREA
*ENTRY: R5=EREC
*       R6=OFFSET INTO SEGMENT (BYTES)
*EXIT:  R6=HI WORD OF SEGMENT ADDRESS
*         =-1 IF NOT RESIDENT
*       R7=LO WORD OF SEGMENT ADDRESS
*

        BSS     4
GETSEG  MOV     R6,@GETSEG-4
        MOV     @4(R5),R6      R6=^SIB
        MOV     @2(R6),@GETSEG-2 BYTE OFFSET IN MEMORY
        JNE     GETS5
        SETO    R6      SEG IS NOT RESIDENT
        RT

GETS5   MOV     *R6,R6         R6=^POOL DESCRIPTOR
        JNE     GETS2          EXTERNAL CODE POOL
        MOV     @GETSEG-2,R7   SEG BASE OFFSET IS ADDRESS
        A       @GETSEG-4,R7
        JNC     GETS1
        INC     R6      HANDLE ROLLOVER
GETS1   RT

GETS2   MOV     @2(R6),R7  GET LO WORD
       MOV  *R6,R6            high word
        A       @GETSEG-2,R7 ADD IN SEGMENT BASE OFFSET
        JNC     GETS3
        INC     R6
GETS3   A       @GETSEG-4,R7
        JNC     GETS4
        INC     R6
GETS4   RT

* * * * * * * *  ***
* * * *THESE COULD BE REPLACED BY MACROS* * * * *

*LONG ADDRESS ADD/SUB

*NOTE: OFFSET VALUE IS UNSIGNED; MUST USE LNGSUB TO REVERSE INDEX

*ENTRY: R1=OFFSET
*       R6=HI WORD
*       R7=LOWORD
*EXIT:  R6,R7 UPDATED ADDRESS

LNGADD  A       R1,R7
        JNC     LGA1
        INC     R6
LGA1    RT

LNGSUB  S       R1,R7
        JOC     LGS1
        DEC     R6
LGS1    RT

* * * * *
*BLDFRM BUILDS A MSCW (ACTIVATION RECORD) ON THE STACK
*MODIFIED FOR LINEAR ADDRESS 1/25/88

*ENTRY:
*       R3=PROC # CALLED
*       R5=EREC FOR SEGMENT CONTAINING PROCEDURE
*       @STATLK=STATIC LINK TO SAVE IN MSCW
*
*EXIT:
*       R5=EREC FOR SEGMENT CONTAINING PROCEDURE
*       R6=SEG FOR SEGMENT CONTAINING PROCEDURE
*       R0,R1,R2,R7 ALTERED

* * * * *NATIVE CODE COMMENTS (12/13/87)
*PER PAGE 5-39 TO 5-41 NO MSCW IS GENERATED IN A CALL TO NATIVE CODE
*PROCEDURE.  IT IS NOT CLEAR FROM MANUAL HOW RETURN IS TO BE HANDLED
*IF CALL CROSSES SEGMENTS.  APPROACH BELOW MAY REQUIRE MODIFICATION

*IF NATIVE CODE, DOES NOT CREATE A MSCW, ALSO DOES NOT CHANGE
*EREC PSEUDO REGISTER ETC.

*EXIT:  ASMPRC (NATIVE CODE FLAG SET); RESPONSIBILTY OF
*       CALLING ROUTINE TO CHECK THIS FLAG AND BRANCH ACCORDINGLY

        BSS     8
BLDFRM  MOV     R11,@SAVRTN
        MOV     R3,@BLDFRM-6 SAVE PROCEDURE #
        CLR     R6           NO OFFSET
        BL      @GETSEG      GET TRUE ADDRESS
        MOV     R6,@BLDFRM-4 SAVE SEG ADDRESS
        MOV     R7,@BLDFRM-2
        BL      @GETWD   R15 HAS SEG LEN (WORDS)
        SLA     R15,1        BYTES
        MOV     R15,R1
        MOV     @BLDFRM-4,R6 SEGMENT ADDRESS
        MOV     @BLDFRM-2,R7
        BL      @LNGADD      R6/7=ADDRESS OF PROCEDURE DICTIONARY
        MOV     @BLDFRM-6,R1
        SLA     R1,1         BYTE OFFSET
        BL      @LNGSUB      R6/7=ADDRESS OF PROCEDURE POINTER
        BL      @GETWD       R15=WORD OFFSET OF PROCEDURE START
        MOV     R15,R1
        SLA     R1,1
        MOV     R1,@BLDFRM-8
        INCT    @BLDFRM-8      IPC VALUE FOR FIRST OPCODE
        MOV     @BLDFRM-4,R6   SEGMENT START ADDRESS
        MOV     @BLDFRM-2,R7
        BL      @LNGADD   R6/7=PROCEDURE START ADDRESS
        BL      @GETWD  R15=DATASIZE
*IN STACK/HEAP MEMORY POOL
        CLR     @ASMPRC NAT CODE FLAG
        SLA     R15,1
        JNC     BLD1    NOT NATIVE CODE

        CLR     R15     NO DATA SPACE ALLOCATED
        INC     @ASMPRC SET FLAG
********************************************

BLD1    AI      R15,MSCWSZ TOTAL TO PUT ON STACK
        MOV     @SKPCHK,R0 SKIP STACK CHECK?
        JNE     BLD2
        MOV     R15,@STKEXT WE NEED THIS MUCH
        MOV     R5,@SAVREC
        BL      @STKCHK
BLD2    CLR     @SKPCHK
BLD3    MOV     @ASMPRC,R0 NATIVE CODE?
       JNE  BLD099            yes, don't change anything else...native code.

BLD4    S       R15,SP   MAKE DATA SPACE
*SAVE THE OLD
        MOV     @CURPRO,@MSPROC(SP)
        MOV     @EREC,@MSENV(SP)
        MOV     IPC,@MSIPC(SP)
        MOV     MP,@MSDYN(SP)
        MOV     @STATLK,*SP   @MSSTAT(SP)

*SET THE NEW REGISTERS
        MOV     @BLDFRM-8,IPC
        MOV     @BLDFRM-6,@CURPRO
        MOV     SP,MP
BLD099  MOV     @SAVRTN,R11
        RT

*CHGSIB FINISHES OFF THE CHANGES NECESSARY
*WHEN SEG BOUNDARIES ARE CROSSED DURING CALLED
*MODIFIED FOR LINEAR ADDRESS 1/26/88

*ENTRY:
*       R5=EREC OF DEST SEG

*EXIT:
*       R2=SIB OF OLD SEG
*       R5=SIB OF NEW SEG
*       R6=SEG ADDRESS OF NEW SEG
*       EREC,EVEC,BASE,CURSEG,SIB UPDATED

CHGSIB  MOV     R5,@EREC  NEW EREC
        MOV     R11,R14 SAVE RETURN
       CLR  R6
        BL      @GETSEG
        MOV     R7,CURSEG   LOW WORD OF CURRENT SEG ADDRESS
       MOV  R6,@CURPOL
        MOV     @ENVVEC(R5),@EVEC NEW EREC
        MOV     @ENVDAT(R5),@BASE
        MOV     @ENVSIB(R5),R5  NEW ^SIB
        MOV     @SIB,R2     OLD ^SIB
        INC     @TIMSTP
        MOV     @TIMSTP,@SEGACT(R5)
        MOV     R5,@SIB
*
CHGS1   B       *R14    RETURN

*STKCHK CALLED TO SEE IF THERE ARE STKEXT BYTES
*IF SPACE, ROUTINE SIMPLY RETURNS
*ELSE RESETS IPC TO IPCFLT; CALLS FAULT

*ENTRY:
*       @IPCFLT RESTART POINT
*       @STKEXT #BYTES REQUIRED
*       @SAVREC CALLER'S EREC
*EXIT:
*      TAKES ACTION AS REQUIRED
*      REGISTERS PRESERVED IF NO ERROR

        BSS     2
STKCHK  MOV     R4,@STKCHK-2
        MOV     @CURTSK,R4
        MOV     @TIBSPL(R4),R4 CURR TIB
        AI      R4,HSMRGN  STACK LOW
        JOC     STK2    OVERFLOW?
        A       @STKEXT,R4 MARGIN+EXT+SPLOW
        JOC     STK2
        C       R4,SP
        JL      STK1
STK2    LI      R4,HSMRGN  STACK FAULT
        A       R4,@STKEXT
        MOV     @IPCFLT,IPC
        BL      @TRAPER
        DATA    STKFLT

STK1    MOV     @STKCHK-2,R4 PUT IT BACK
        RT

*SEGMENT CHECK--DETERMINES SEGMENT PRESENCE
* ISSUES SEGMENT FAULT IF NOT IN POOL (TO LOAD OFF DISK)

*ENTRY: (@SEGCHK):
*       IPCFLT PREPARED JUST IN CASE
*       R5=LOCAL SEG #
*ENTRY: (@SGCHK1):
*       R5=EREC OF SEGMENT
*EXIT:
*       R1 ALTERED
*       R4=LOWORD OF SEGMENT ADDRESS
*       R5=EREC
* VECTORS TO TRAPER IF SEGMENT FAULT

SEGCHK  SLA     R5,1
        A       @EVEC,R5
        MOV     *R5,R5  CONTAINS EREC
       JNE  SGCHK1
       MOV  @IPCFLT,IPC
       BL   @TRAPER
       DATA NOPROC

SGCHK1  MOV     @ENVSIB(R5),R1  R5=^SIB
        MOV     @SEGBAS(R1),R4  SEGMENT BASE IN POOL
        JEQ     SGCHK4   SEGMENT NOT IN MEMORY
        RT              EVERYTHING OK

SGCHK4  MOV     @IPCFLT,IPC SEG NOT IN POOL
        BL      @TRAPER  SEGMENT FAULT
        DATA    SEGFLT

*SETUP SEGMENT SEX FOR NEW SEGMENT
*
*ENTRY: R5=EREC
*EXIT:  R4=SEGHI
*       R0-R2,R6,R7 ALTERED
*SETS:  SEXOK,SEGHI,CPOOL,CPOFST
* ALL FIELDS REFERENCED ARE PRE-FLIPPED BY
* BY OPERATING SYSTEM

       BSS 4                  12/18/90 (added)
*
CHKSEX  MOV     R11,R0
        CLR     @SEXOK
       CLR  R6
        BL      @GETSEG
        MOV     R6,@CHKSEX-4  SAVE SEGMENT START
        MOV     R7,@CHKSEX-2
        LI      R1,12
        BL      @LNGADD
        BL      @GETWD  GET SEX WORD
        CI      R15,1    CHECK SEX
        JNE     CHKSX1
        INC     @SEXOK

CHKSX1  MOV     @CHKSEX-4,R6
        MOV     @CHKSEX-2,R7
        BL      @GETWD  FIRST WORD IN SEGMENT
        SLA     R15,1   BYTE OFFSET
       MOV  R15,@SEGHI
*
        MOV     @CHKSEX-4,R6  SEGMENT START
        MOV     @CHKSEX-2,R7    "       "
        LI      R1,14
        BL      @LNGADD
        BL      @GETWD
        SLA     R15,1   BYTE VALUE
        MOV     R15,@CPOFST   BYTE OFFSET OF CONSTANT POOL WITHIN SEG
        MOV     R15,R1
       MOV  @CHKSEX-4,R6      SEGMENT START
       MOV  @CHKSEX-2,R7        "       "
        BL      @LNGADD
       MOV  R7,@CPOOL         LO WORD ADDRESS OF CONSTANT POOL IN SEG
        B       *R0
